"""
Search the Typesense code index.

Usage:
    search.py "query" [--ext cs] [--sub myservice] [--limit 10] [--symbols] [--json]

Modes:
    Default:         full-text search across filenames, symbols, and content
    --symbols:       search only C# symbol names (class/interface/method)
    --implements X:  find types that inherit from or implement X            [T1]
    --callers X:     find call sites that invoke method X                   [T1]
    --sig X:         find methods whose signature contains X                [T1]
    --uses X:        find files that reference type X in declarations       [T2]
    --attr X:        find files decorated with attribute X                  [T2]
    --ext EXT:       filter by file extension (e.g. cs, h, py)
    --sub NAME:      filter by subsystem (e.g. myservice, core, myapp)
    --limit N:       max results (default 10)

Examples:
    search.py "IStorageProvider"
    search.py "GetItemsAsync" --ext cs --sub myservice
    search.py "WriteItemsAsync" --symbols
    search.py "circuit breaker" --sub core --limit 5
    search.py "IStorageProvider" --implements     # find implementors
    search.py "GetItemsAsync" --callers           # find call sites
    search.py "Task GetItemsAsync" --sig          # find by signature
    search.py "ItemInfo" --uses                   # find type references
    search.py "Obsolete" --attr                   # find by attribute
"""


def _require_wsl_venv():
    import sys, os
    if sys.platform != "linux":
        sys.exit("ERROR: must run under WSL, not Windows Python.")
    try:
        if "microsoft" not in open("/proc/version").read().lower():
            sys.exit("ERROR: must run under WSL (Microsoft kernel).")
    except OSError:
        sys.exit("ERROR: cannot read /proc/version.")
    if sys.prefix == sys.base_prefix:
        sys.exit("ERROR: must run inside a virtualenv (activate ~/.local/mcp-venv).")
_require_wsl_venv()
del _require_wsl_venv


import os
import sys
import json
import argparse

_util_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, _util_dir)

import typesense
from codesearch.config import TYPESENSE_CLIENT_CONFIG, COLLECTION


def get_client():
    return typesense.Client(TYPESENSE_CLIENT_CONFIG)


def search(query, ext=None, sub=None, limit=10,
           symbols_only=False, implements=False, callers=False,
           sig=False, uses=False, attr=False):
    client = get_client()

    # Determine query_by based on mode
    if implements:
        query_by = "base_types,class_names,filename"
    elif callers:
        query_by = "call_sites,filename"
    elif sig:
        query_by = "method_sigs,method_names,filename"
    elif uses:
        query_by = "type_refs,symbols,class_names,filename"
    elif attr:
        query_by = "attributes,filename"
    elif symbols_only:
        query_by = "symbols,class_names,method_names,filename"
    else:
        query_by = "filename,symbols,class_names,method_names,content"

    filter_parts = []
    if ext:
        filter_parts.append(f"extension:={ext.lstrip('.')}")
    if sub:
        filter_parts.append(f"subsystem:={sub}")
    filter_by = " && ".join(filter_parts) if filter_parts else ""

    params = {
        "q": query,
        "query_by": query_by,
        "per_page": limit,
        "highlight_full_fields": "symbols,class_names,method_names,filename,base_types,method_sigs",
        "snippet_threshold": 30,
        "num_typos": "1",
        "prefix": "false",
    }
    if filter_by:
        params["filter_by"] = filter_by

    params["facet_by"]  = "subsystem,extension"
    # Prefer .cs files (priority=3) when no explicit extension filter is set
    if not ext:
        params["sort_by"] = "_text_match:desc,priority:desc"

    try:
        result = client.collections[COLLECTION].documents.search(params)
    except Exception as e:
        msg = str(e)
        if "400" in msg or "non-indexed" in msg or "index" in msg.lower():
            print(f"ERROR: Schema issue - re-index with: python codesearch/indexer.py --reset")
        else:
            print(f"ERROR: Cannot reach Typesense â€” is the server running?")
            print(f"  Windows: ts.cmd start   |   WSL: ts_start.cmd")
        print(f"  Detail: {e}")
        sys.exit(1)

    return result, query_by


def format_results(result, query, query_by, show_facets=False):
    hits = result.get("hits", [])
    total = result.get("found", 0)

    print(f"=== Search: \"{query}\" ({total} results) [fields: {query_by}] ===\n")

    if show_facets or (total > 0 and not hits):
        for fc in result.get("facet_counts", []):
            field = fc["field_name"]
            counts = fc.get("counts", [])
            if counts:
                parts = ", ".join(f"{c['value']}({c['count']})" for c in counts[:15])
                print(f"  [{field}] {parts}")
        print()

    if not hits:
        print("No results found.")
        return

    for i, hit in enumerate(hits, 1):
        doc = hit["document"]
        rel = doc["relative_path"]
        ns = doc.get("namespace", "")

        print(f"{i}. {rel}")

        # Show C# symbol context
        class_names = doc.get("class_names", [])
        method_names = doc.get("method_names", [])
        base_types = doc.get("base_types", [])
        method_sigs = doc.get("method_sigs", [])
        attributes = doc.get("attributes", [])
        usings = doc.get("usings", [])

        if class_names:
            print(f"   Classes    : {', '.join(class_names[:5])}")
        if base_types:
            print(f"   Implements : {', '.join(base_types[:5])}")
        if method_sigs:
            print(f"   Signatures : {'; '.join(method_sigs[:3])}")
        elif method_names:
            print(f"   Members    : {', '.join(method_names[:6])}")
        if attributes:
            print(f"   Attributes : {', '.join(attributes[:5])}")
        if usings:
            print(f"   Usings     : {', '.join(usings[:4])}")
        if ns:
            print(f"   NS         : {ns}")

        # Highlighted snippet
        highlights = hit.get("highlights", [])
        for hl in highlights:
            if hl.get("field") in ("content", "method_sigs", "base_types", "call_sites",
                                   "type_refs", "attributes"):
                snippet = hl.get("snippet", "").replace("\n", " ").strip()
                # Strip BOM and non-printable chars that break Windows console
                snippet = snippet.encode("ascii", errors="replace").decode("ascii")
                if snippet:
                    print(f"   Match      : ...{snippet}...")
                break

        print()


def main():
    ap = argparse.ArgumentParser(description=__doc__,
                                 formatter_class=argparse.RawDescriptionHelpFormatter)
    ap.add_argument("query", help="Search query")
    ap.add_argument("--ext",    help="Filter by extension (e.g. cs, h, py)")
    ap.add_argument("--sub",    help="Filter by subsystem (e.g. myservice)")
    ap.add_argument("--limit",  type=int, default=10, help="Max results (default 10)")
    ap.add_argument("--symbols", action="store_true",
                    help="Search only C# symbol names")
    ap.add_argument("--implements", action="store_true",
                    help="[T1] Find types implementing/inheriting the query")
    ap.add_argument("--callers", action="store_true",
                    help="[T1] Find files that call the queried method")
    ap.add_argument("--sig", action="store_true",
                    help="[T1] Search method signatures (return type + param types)")
    ap.add_argument("--uses", action="store_true",
                    help="[T2] Find files that reference the queried type")
    ap.add_argument("--attr", action="store_true",
                    help="[T2] Find files decorated with the queried attribute")
    ap.add_argument("--facets", action="store_true",
                    help="Show subsystem/extension facet counts in output")
    ap.add_argument("--json", action="store_true",
                    help="Output raw JSON from Typesense")
    args = ap.parse_args()

    result, query_by = search(
        query=args.query,
        ext=args.ext,
        sub=args.sub,
        limit=args.limit,
        symbols_only=args.symbols,
        implements=args.implements,
        callers=args.callers,
        sig=args.sig,
        uses=args.uses,
        attr=args.attr,
    )

    if args.json:
        print(json.dumps(result, indent=2))
    else:
        format_results(result, args.query, query_by, show_facets=args.facets)


if __name__ == "__main__":
    main()
